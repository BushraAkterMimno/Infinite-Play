<!doctype html>
<html lang="bn">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Catch the Stars — Smooth Tailwind Game</title>
  <!-- Tailwind CDN -->
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    body { -webkit-tap-highlight-color: transparent; }
    .star {
      will-change: transform, opacity;
      transition: transform 200ms linear, opacity 350ms ease;
      touch-action: manipulation;
    }
    .pop {
      transform: scale(1.25) rotate(-10deg);
      opacity: 0;
    }
    
    .bg-scene { 
      background: radial-gradient(circle at 10% 20%, #0f172a 0%, #071028 40%, #001025 100%); 
    }
  </style>
</head>
<body class="min-h-screen bg-scene text-white flex items-center justify-center p-4">
  <div class="w-full max-w-3xl mx-auto">
    <header class="flex items-center justify-between mb-4">
      <h1 class="text-2xl font-extrabold tracking-tight">Catch the Stars ✨</h1>
      <div class="text-right">
        <div class="text-sm">Level <span id="level">1</span></div>
        <div class="text-2xl font-bold" id="score">0</div>
      </div>
    </header>

    <main class="relative bg-gradient-to-b from-slate-800/30 to-transparent rounded-2xl shadow-2xl overflow-hidden" style="height:64vh;">
      <!-- top HUD -->
      <div class="absolute top-4 left-4 z-20">
        <button id="startBtn" class="px-3 py-1 bg-indigo-600/90 rounded-md text-sm hover:bg-indigo-500">Start</button>
        <button id="pauseBtn" class="px-3 py-1 ml-2 bg-yellow-600/80 rounded-md text-sm hover:bg-yellow-500">Pause</button>
        <button id="resetBtn" class="px-3 py-1 ml-2 bg-red-600/80 rounded-md text-sm hover:bg-red-500">Reset</button>
      </div>

      <div class="absolute top-4 right-4 text-right z-20">
        <div class="text-xs opacity-80">Time</div>
        <div id="timer" class="font-mono text-lg">00:30</div>
      </div>

      <!-- game area -->
      <div id="playArea" class="relative w-full h-full" role="application" aria-label="Game area">
        <div id="message" class="absolute inset-0 flex items-center justify-center pointer-events-none">
        </div>
      </div>
    </main>

    <footer class="mt-4 text-sm text-gray-300">
      Click or tap the moving stars to catch them. Speed increases with level. Mobile-friendly.
    </footer>
  </div>

  <script>
    // Game configuration
    const config = {
      baseTimeSec: 30,
      baseSpawnRate: 1000, 
      maxStarsOnScreen: 7,
      starSizeRange: [36, 72], 
      levelUpEvery: 10, 
      maxLevel: 10
    };

    //  State
    let score = 0;
    let level = 1;
    let timeLeft = config.baseTimeSec;
    let running = false;
    let spawnTimer = null;
    let gameTimer = null;
    let stars = new Map(); 
    let starCounter = 0;

    // DOM
    const playArea = document.getElementById('playArea');
    const scoreEl = document.getElementById('score');
    const levelEl = document.getElementById('level');
    const timerEl = document.getElementById('timer');
    const startBtn = document.getElementById('startBtn');
    const pauseBtn = document.getElementById('pauseBtn');
    const resetBtn = document.getElementById('resetBtn');
    const message = document.getElementById('message');

    // Audio
    let audioCtx = null;
    function playClick(pitch = 880, duration = 0.06) {
      if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
      const o = audioCtx.createOscillator();
      const g = audioCtx.createGain();
      o.type = 'sine';
      o.frequency.value = pitch;
      g.gain.setValueAtTime(0.0001, audioCtx.currentTime);
      g.gain.exponentialRampToValueAtTime(0.12, audioCtx.currentTime + 0.01);
      g.gain.exponentialRampToValueAtTime(0.0001, audioCtx.currentTime + duration);
      o.connect(g); g.connect(audioCtx.destination);
      o.start();
      o.stop(audioCtx.currentTime + duration + 0.02);
    }

    //  Utility 
    function rand(min, max) { return Math.random() * (max - min) + min; }
    function clamp(v, a, b) { return Math.max(a, Math.min(b, v)); }
    function formatTime(sec) {
      const s = Math.max(0, Math.floor(sec));
      return String(Math.floor(s / 60)).padStart(2,'0') + ':' + String(s % 60).padStart(2,'0');
    }

    // Core
    function spawnStar() {
      if (!running) return;
      if (stars.size >= config.maxStarsOnScreen) return;

      const id = ++starCounter;
      const el = document.createElement('button'); 
      el.className = 'star absolute rounded-full flex items-center justify-center shadow-xl';
      el.setAttribute('aria-label', 'star');
      el.dataset.id = id;

      // random size
      const size = Math.round(rand(...config.starSizeRange) / (1 + (level-1)*0.05));
      el.style.width = size + 'px';
      el.style.height = size + 'px';

      // star inner: SVG
      el.innerHTML = `
        <svg viewBox="0 0 24 24" width="${size*0.8}" height="${size*0.8}" fill="none" stroke="gold" stroke-width="1.4" stroke-linejoin="round" stroke-linecap="round">
          <path d="M12 2.9l1.9 3.9 4.3.6-3.1 3 0.7 4.3L12 14.8 7.2 15.7l0.7-4.3L4.8 8.4l4.3-.6L12 2.9z" fill="gold"/>
        </svg>
      `;

      // initial position
      const pad = 10;
      const areaRect = playArea.getBoundingClientRect();
      const x = rand(pad, areaRect.width - size - pad);
      const y = rand(pad + 30, areaRect.height - size - pad); 

      el.style.left = x + 'px';
      el.style.top = y + 'px';
      el.style.opacity = '1';
      el.style.transform = 'translateZ(0)';

      // physics-like velocity
      const speedBase = 0.015 + 0.01 * level; 
      const vx = rand(-1,1) * speedBase * (50 + size);
      const vy = rand(-1,1) * speedBase * (50 + size);

      const createdAt = performance.now();
      const starObj = { id, el, x, y, vx, vy, size, createdAt, last: createdAt };
      stars.set(id, starObj);
      playArea.appendChild(el);

      // click/tap handler
      const onCatch = (ev) => {
        ev.preventDefault();
        catchStar(id);
      };
      el.addEventListener('click', onCatch, { passive: false });
      el.addEventListener('touchstart', onCatch, { passive: false });

      // gentle entrance
      el.style.transform = 'scale(0.9)';
      el.style.opacity = '0';
      requestAnimationFrame(() => {
        el.style.transition = 'transform 220ms cubic-bezier(.2,.9,.2,1), opacity 220ms ease';
        el.style.transform = 'scale(1)';
        el.style.opacity = '1';
      });
    }

    // Update loop: move stars
    let lastFrame = performance.now();
    function frame(now) {
      const dt = Math.min(50, now - lastFrame);
      lastFrame = now;

      // move each star
      const areaRect = playArea.getBoundingClientRect();
      stars.forEach((s, id) => {
        // integrate
        s.x += s.vx * dt;
        s.y += s.vy * dt;

        // bounce off boundaries
        if (s.x < 6) { s.x = 6; s.vx *= -1; }
        if (s.x + s.size > areaRect.width - 6) { s.x = areaRect.width - s.size - 6; s.vx *= -1; }
        if (s.y < 6) { s.y = 6; s.vy *= -1; }
        if (s.y + s.size > areaRect.height - 6) { s.y = areaRect.height - s.size - 6; s.vy *= -1; }

        // apply small random acceleration for organic motion
        s.vx += rand(-0.0009999,0.0009999) * (6 + level);
        s.vy += rand(-0.0009999,0.0009999) * (6 + level);
        s.vx = clamp(s.vx, -0.35 - 0.04*level, 0.35 + 0.04*level);
        s.vy = clamp(s.vy, -0.35 - 0.04*level, 0.35 + 0.04*level);

        s.el.style.left = s.x + 'px';
        s.el.style.top = s.y + 'px';
      });

      // continue loop
      if (running) requestAnimationFrame(frame);
    }

    // Catch star
    function catchStar(id) {
      const s = stars.get(id);
      if (!s) return;
      // pop animation
      s.el.classList.add('pop');
      s.el.style.transition = 'transform 260ms ease, opacity 260ms ease';
      playClick(1000 + level*60, 0.05);
      // remove after short delay
      setTimeout(() => {
        try { s.el.remove(); } catch(e){}
        stars.delete(id);
      }, 260);

      // update score & maybe level
      score += Math.max(1, Math.round(5 - level*0.2));
      scoreEl.textContent = score;
      checkLevelUp();
    }

    function checkLevelUp() {
      const newLevel = Math.min(config.maxLevel, Math.floor(score / config.levelUpEvery) + 1);
      if (newLevel > level) {
        level = newLevel;
        levelEl.textContent = level;
        showMessage('Level ' + level, 1200);
        // speed up spawn
        restartSpawnTimer();
      }
    }

    // Timers control
    function startGame() {
      if (running) return;
      running = true;
      if (audioCtx && audioCtx.state === 'suspended') audioCtx.resume();
      lastFrame = performance.now();
      requestAnimationFrame(frame);
      startSpawnTimer();
      startCountdown();
      showMessage('Go!', 800);
    }

    function pauseGame() {
      running = !running;
      if (running) {
        lastFrame = performance.now();
        requestAnimationFrame(frame);
        startSpawnTimer();
        startCountdown();
        showMessage('Resumed', 700);
      } else {
        stopSpawnTimer();
        stopCountdown();
        showMessage('Paused', 700);
      }
    }

    function resetGame() {
      running = false;
      stopSpawnTimer();
      stopCountdown();
      // remove all stars
      stars.forEach(s => { try{ s.el.remove(); }catch{} });
      stars.clear();
      score = 0; level = 1; timeLeft = config.baseTimeSec;
      scoreEl.textContent = score; levelEl.textContent = level; timerEl.textContent = formatTime(timeLeft);
      showMessage('Ready', 900);
    }

    function startSpawnTimer() {
      stopSpawnTimer();
      const rate = Math.max(300, config.baseSpawnRate - (level-1) * 80);
      spawnTimer = setInterval(() => spawnStar(), rate);
      // spawn one immediately
      spawnStar();
    }
    function stopSpawnTimer(){ if (spawnTimer) { clearInterval(spawnTimer); spawnTimer = null; } }
    function restartSpawnTimer(){ if (running) startSpawnTimer(); }

    function startCountdown() {
      stopCountdown();
      gameTimer = setInterval(() => {
        timeLeft -= 1;
        timerEl.textContent = formatTime(timeLeft);
        if (timeLeft <= 0) {
          endGame();
        }
      }, 1000);
    }
    function stopCountdown() { if (gameTimer) { clearInterval(gameTimer); gameTimer = null; } }

    function endGame() {
      running = false;
      stopSpawnTimer(); stopCountdown();
      showMessage('Game Over — Score: ' + score, 3000);
    }

    // UI messages
    let msgTimer = null;
    function showMessage(txt, ms=1200) {
      clearTimeout(msgTimer);
      message.innerHTML = `<div class="pointer-events-none bg-white/5 backdrop-blur-sm border border-white/10 px-6 py-3 rounded-2xl text-center shadow-lg">
        <div class="font-semibold text-lg">${txt}</div>
      </div>`;
      msgTimer = setTimeout(()=> { message.innerHTML = ''; }, ms);
    }

    // Controls wiring
    startBtn.addEventListener('click', () => { startGame(); });
    pauseBtn.addEventListener('click', () => { pauseGame(); });
    resetBtn.addEventListener('click', () => { resetGame(); });

    // keyboard support: Space to start/pause, R to reset
    window.addEventListener('keydown', (e) => {
      if (e.code === 'Space') { e.preventDefault(); pauseGame(); }
      if (e.key.toLowerCase() === 'r') { resetGame(); }
    });

    // responsive: on resize, keep stars inside
    window.addEventListener('resize', () => {
      const areaRect = playArea.getBoundingClientRect();
      stars.forEach(s => {
        s.x = clamp(s.x, 6, Math.max(6, areaRect.width - s.size - 6));
        s.y = clamp(s.y, 6, Math.max(6, areaRect.height - s.size - 6));
      });
    });

    // initialize hud
    timerEl.textContent = formatTime(timeLeft);
    scoreEl.textContent = score;
    levelEl.textContent = level;

    // touch hint: start on first tap (resume audio)
    document.addEventListener('touchstart', function once() {
      if (!audioCtx) {
        try { audioCtx = new (window.AudioContext || window.webkitAudioContext)(); audioCtx.resume(); } catch(e){}
      } else if (audioCtx.state === 'suspended') audioCtx.resume();
      document.removeEventListener('touchstart', once);
    });

    // auto-focus playArea for accessibility
    playArea.tabIndex = 0;
    playArea.addEventListener('keydown', (e)=>{
      if (e.key === 'Enter') pauseGame();
    });

    // start with a friendly message
    showMessage('Click Start to Play', 2500);
  </script>
</body>
</html>